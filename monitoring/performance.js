const client = require('prom-client');\nconst logger = require('../utils/logger');\n\nclass PerformanceMonitor {\n  constructor() {\n    // Create a Registry\n    this.register = new client.Registry();\n    \n    // Add default metrics\n    client.collectDefaultMetrics({ register: this.register });\n    \n    // Custom metrics for GPS tracking\n    this.gpsConnections = new client.Gauge({\n      name: 'gps_active_connections',\n      help: 'Number of active GPS device connections',\n      registers: [this.register]\n    });\n    \n    this.gpsMessagesProcessed = new client.Counter({\n      name: 'gps_messages_processed_total',\n      help: 'Total number of GPS messages processed',\n      labelNames: ['protocol', 'message_type'],\n      registers: [this.register]\n    });\n    \n    this.gpsMessageProcessingTime = new client.Histogram({\n      name: 'gps_message_processing_duration_seconds',\n      help: 'Time spent processing GPS messages',\n      labelNames: ['protocol', 'message_type'],\n      buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5],\n      registers: [this.register]\n    });\n    \n    this.locationUpdates = new client.Counter({\n      name: 'location_updates_total',\n      help: 'Total number of location updates processed',\n      labelNames: ['device_id'],\n      registers: [this.register]\n    });\n    \n    this.redisOperations = new client.Counter({\n      name: 'redis_operations_total',\n      help: 'Total number of Redis operations',\n      labelNames: ['operation', 'status'],\n      registers: [this.register]\n    });\n    \n    this.databaseOperations = new client.Counter({\n      name: 'database_operations_total',\n      help: 'Total number of database operations',\n      labelNames: ['operation', 'status'],\n      registers: [this.register]\n    });\n    \n    this.alertsTriggered = new client.Counter({\n      name: 'alerts_triggered_total',\n      help: 'Total number of alerts triggered',\n      labelNames: ['alert_type', 'device_id'],\n      registers: [this.register]\n    });\n    \n    this.commandsSent = new client.Counter({\n      name: 'commands_sent_total',\n      help: 'Total number of commands sent to devices',\n      labelNames: ['command_type', 'status'],\n      registers: [this.register]\n    });\n    \n    this.batchProcessingTime = new client.Histogram({\n      name: 'batch_processing_duration_seconds',\n      help: 'Time spent processing batches',\n      labelNames: ['batch_type'],\n      buckets: [0.1, 0.5, 1, 2, 5, 10],\n      registers: [this.register]\n    });\n    \n    this.memoryUsage = new client.Gauge({\n      name: 'nodejs_memory_usage_bytes',\n      help: 'Node.js memory usage in bytes',\n      labelNames: ['type'],\n      registers: [this.register]\n    });\n    \n    // Start memory monitoring\n    this.startMemoryMonitoring();\n  }\n  \n  // GPS Connection Metrics\n  setActiveConnections(count) {\n    this.gpsConnections.set(count);\n  }\n  \n  incrementMessagesProcessed(protocol, messageType) {\n    this.gpsMessagesProcessed.inc({ protocol, message_type: messageType });\n  }\n  \n  recordMessageProcessingTime(protocol, messageType, duration) {\n    this.gpsMessageProcessingTime.observe({ protocol, message_type: messageType }, duration);\n  }\n  \n  // Location Metrics\n  incrementLocationUpdates(deviceId) {\n    this.locationUpdates.inc({ device_id: deviceId });\n  }\n  \n  // Redis Metrics\n  recordRedisOperation(operation, status) {\n    this.redisOperations.inc({ operation, status });\n  }\n  \n  // Database Metrics\n  recordDatabaseOperation(operation, status) {\n    this.databaseOperations.inc({ operation, status });\n  }\n  \n  // Alert Metrics\n  recordAlert(alertType, deviceId) {\n    this.alertsTriggered.inc({ alert_type: alertType, device_id: deviceId });\n  }\n  \n  // Command Metrics\n  recordCommand(commandType, status) {\n    this.commandsSent.inc({ command_type: commandType, status });\n  }\n  \n  // Batch Processing Metrics\n  recordBatchProcessing(batchType, duration) {\n    this.batchProcessingTime.observe({ batch_type: batchType }, duration);\n  }\n  \n  // Memory Monitoring\n  startMemoryMonitoring() {\n    setInterval(() => {\n      const memUsage = process.memoryUsage();\n      this.memoryUsage.set({ type: 'rss' }, memUsage.rss);\n      this.memoryUsage.set({ type: 'heapTotal' }, memUsage.heapTotal);\n      this.memoryUsage.set({ type: 'heapUsed' }, memUsage.heapUsed);\n      this.memoryUsage.set({ type: 'external' }, memUsage.external);\n      \n      // Log memory usage if it's high\n      const heapUsedMB = memUsage.heapUsed / 1024 / 1024;\n      if (heapUsedMB > 1000) { // Alert if heap usage > 1GB\n        logger.warn('High memory usage detected', {\n          heapUsedMB: heapUsedMB.toFixed(2),\n          heapTotalMB: (memUsage.heapTotal / 1024 / 1024).toFixed(2)\n        });\n      }\n    }, 10000); // Every 10 seconds\n  }\n  \n  // Get metrics for Prometheus\n  async getMetrics() {\n    return await this.register.metrics();\n  }\n  \n  // Get current stats\n  getStats() {\n    const memUsage = process.memoryUsage();\n    return {\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: {\n        rss: Math.round(memUsage.rss / 1024 / 1024),\n        heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024),\n        heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024),\n        external: Math.round(memUsage.external / 1024 / 1024)\n      },\n      cpu: process.cpuUsage(),\n      pid: process.pid\n    };\n  }\n  \n  // Performance timing helper\n  startTimer(name) {\n    return {\n      name,\n      start: process.hrtime.bigint(),\n      end: () => {\n        const duration = Number(process.hrtime.bigint() - this.start) / 1e9;\n        logger.performance(name, duration, 'seconds');\n        return duration;\n      }\n    };\n  }\n  \n  // Health check\n  getHealthStatus() {\n    const memUsage = process.memoryUsage();\n    const heapUsedPercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;\n    \n    const status = {\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: {\n        heapUsedPercent: heapUsedPercent.toFixed(2),\n        heapUsedMB: (memUsage.heapUsed / 1024 / 1024).toFixed(2)\n      }\n    };\n    \n    // Determine health status\n    if (heapUsedPercent > 90) {\n      status.status = 'critical';\n      status.issues = ['High memory usage'];\n    } else if (heapUsedPercent > 75) {\n      status.status = 'warning';\n      status.issues = ['Elevated memory usage'];\n    }\n    \n    return status;\n  }\n}\n\nmodule.exports = new PerformanceMonitor();